/*
 * Created by Martin Winkelhofer 02,03,04/2016
 * W-Dimension / wdim / wdim0 / maarty.w@gmail.com
 *    _____ __          ____         ______         __
 *   / __(_) /__ ___   / __ \___    / __/ /__ ____ / /
 *  / _// / / -_|_-<  / /_/ / _ \  / _// / _ `(_-</ _ \
 * /_/ /_/_/\__/___/  \____/_//_/ /_/ /_/\_,_/___/_//_/
 *
 * This file is part of WFOF - W-Dimension's Files On Flash (for ESP8266).
 *
 * WFOF is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * WFOF is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with WFOF. If not, see <http://www.gnu.org/licenses/>.
 */

#include <espressif/esp_common.h>

#include "wfof.h"      //WFOF types/structures
#include "wfof_data.h" //WFOF data array wfof_Data[] with data to be written on FLASH (files in dir "wfof/content") + data array wfof_FTab[] describing wfof_Data[] content <- generated by wfof_gen tool
#include "wfof_idxs.h" //WFOF constants describing wfof_Data[] content <- generated by wfof_gen tool

#define WFOF_VERSION			"v2.0" //04/2016

int8_t ICACHE_FLASH_ATTR wfof_get_file_info(char* FName, uint8_t* RetFileIndex, uint32_t* RetSize){
/* Tries to find file of name FName in the list of files that were in dir "wfof/content" when generating wfof_data.h
 * If such file exists (has been included into wfof_Data[] => is written on SPI FLASH):
 * - fills RetFileIndex by file index (that can be used by wfof_get_file_data(...))
 * - fills RetSize by file size
 * - returns 0
 * If such file doesn't exist:
 * - fills RetFileIndex by file WFOF_INVALID_INDEX
 * - fills RetSize by 0
 * - returns -1
 * You can also use constants defined in "wfof_idxs.h" if you know the name of file exactly to save time.
 */
	uint8_t FIdx;
	for(FIdx=0;FIdx<wfof_FTab.FilesCnt;FIdx++){
		if(strcasecmp(wfof_FTab.Files[FIdx].Name,FName)==0){
			*RetFileIndex = FIdx;
			*RetSize = wfof_FTab.Files[FIdx].Size;
			return 0;
		}
	}
	*RetFileIndex = WFOF_INVALID_INDEX;
	*RetSize = 0;
	return -1;
}

uint32_t ICACHE_FLASH_ATTR wfof_get_file_data(uint8_t FileIndex, uint8_t* RetBuf, uint32_t Offs, uint32_t Bytes){
/* Fills buffer RetBuf by data of file specified by FileIndex.
 * Offs is zero based offset in respect of the start of the file data.
 * Bytes is how many bytes you want to get (you can get less than specified if the file is smaller than that).
 * Returns number of really copied bytes on success.
 * Returns 0 if such FileIndex doesn't exist OR the offset is beyond the end of the file OR reading of SPI FLASH failed.
 * FLASH is mapped to normal address space, but access must be 4-bytes aligned (in copy operation from FLASH both addresses
 * must be 4-bytes aligned). Since Offs can be anything, we need to manage 32-bit copy from FLASH to temporary variable
 * and chop into bytes individually.
 * Use wfof_get_file_data_fast(...) if possible.
 */
	if((FileIndex>=wfof_FTab.FilesCnt)||(Bytes==0)) return 0;
	int32_t RemainingBytes = (int32_t)wfof_FTab.Files[FileIndex].Size - Offs;
	if(RemainingBytes<=0) return 0;
	if(RemainingBytes<Bytes) Bytes = RemainingBytes;
	//
	/* Unfortunately, we cannot copy like this:
	 * (causes "Fatal exception 3")
	uint8_t* SrcPtr = (uint8_t*)(((uint32_t)wfof_Data) + (wfof_FTab.Files[FileIndex].Offs*WFOF_ALIGN_BYTES) + Offs);
	uint32_t i = Bytes;
	while(i-->0){
	 	*(RetBuf++) = *(SrcPtr++); //8-bit copy
	}
	*/
	uint32_t* SrcPtr = (uint32_t*)(((uint32_t)wfof_Data) + (wfof_FTab.Files[FileIndex].Offs*WFOF_ALIGN_BYTES) + Offs);
	uint8_t ModOffs = (uint32_t)SrcPtr % 4;
	SrcPtr = (uint32_t*)(((uint8_t*)SrcPtr) - ModOffs); //make SrcPtr 4-bytes aligned
	//
	uint32_t ICACHE_STORE_ATTR Data32 = *(SrcPtr++);
	uint8_t* Data8Ptr = ((uint8_t*)&Data32)+ModOffs;
	uint32_t i = Bytes;
	while(i-->0){
		if(ModOffs>=4){
			Data32 = *(SrcPtr++); //32-bit copy, both addresses are 4-bytes aligned
			ModOffs=0;
			Data8Ptr = (uint8_t*)&Data32;
		}
		*(RetBuf++) = *(Data8Ptr++); //8-bit copy - get only byte that we're interested in this iteration and copy to RetBuf
		ModOffs++;
	}
	//
	return Bytes;
}

uint32_t /*ICACHE_FLASH_ATTR*/ wfof_get_file_data_fast(uint8_t FileIndex, uint32_t* RetBuf, uint32_t Offs, uint32_t Bytes){
/* The same as above, but uses 32-bit copy.
 * ! RetBuf must be 4-bytes aligned array and Offs must be multiples of 4 otherwise the ESP8266 core
 * will detect unaligned memory access and raises "Fatal exception 9".
 * Bytes can be any number, but is rounded up to be multiple of 4 => your RetBuf must have enough space
 * to accommodate all data including this rounding up.
 * Use wfof_gen with <align_bytes> = 4 to generate data arrays for this function.
 */
	if((FileIndex>=wfof_FTab.FilesCnt)||(Bytes==0)) return 0;
	uint32_t* SrcPtr = (uint32_t*)(((uint32_t)wfof_Data) + (wfof_FTab.Files[FileIndex].Offs*WFOF_ALIGN_BYTES) + Offs);
	if((Offs % 4)||((uint32_t)SrcPtr % 4)) return 0; //would cause unaligned memory access => wrong usage of this function, exit
	//
	int32_t RemainingBytes = (int32_t)wfof_FTab.Files[FileIndex].Size - Offs;
	if(RemainingBytes<=0) return 0;
	if(RemainingBytes<Bytes) Bytes = RemainingBytes;
	//
	int32_t i = Bytes;
	while(i>0){
		*(RetBuf++) = *(SrcPtr++); //32-bit copy, both addresses are 4-bytes aligned
		i-=4;
	}
	//
	return Bytes;
}

int8_t ICACHE_FLASH_ATTR wfof_find_char_pos(uint8_t FileIndex, uint32_t Offs, char Ch, uint32_t* RetPos){
/* Tries to locate first occurrence of char Ch in data of file specified by FileIndex,
 * starting the search at offset Offs (in respect to first data byte of the file).
 * Returns 0 and fills RetPos if Ch was found. RetPos is the relative to Offs.
 * Returns -1 if Ch was not found OR FileIndex doesn't exist OR the offset is beyond the end of the file OR reading of SPI FLASH failed.
 */
	if(FileIndex>=wfof_FTab.FilesCnt) return -1;
	if(Offs>=wfof_FTab.Files[FileIndex].Size) return -1;
	//
	uint32_t RemainingBytes = wfof_FTab.Files[FileIndex].Size - Offs;
	//
	uint32_t* SrcPtr = (uint32_t*)(((uint32_t)wfof_Data) + (wfof_FTab.Files[FileIndex].Offs*WFOF_ALIGN_BYTES) + Offs);
	uint8_t ModOffs = (uint32_t)SrcPtr % 4;
	SrcPtr = (uint32_t*)(((uint8_t*)SrcPtr) - ModOffs); //make SrcPtr 4-bytes aligned
	//
	uint32_t ICACHE_STORE_ATTR Data32 = *(SrcPtr++);
	uint8_t* Data8Ptr = ((uint8_t*)&Data32)+ModOffs;
	uint32_t Idx = 0;
	while(RemainingBytes-->0){
		if(ModOffs>=4){
			Data32 = *(SrcPtr++); //32-bit copy, both addresses are 4-bytes aligned
			ModOffs=0;
			Data8Ptr = (uint8_t*)&Data32;
		}
		char CurrCh = *(Data8Ptr++); //8-bit copy - get only byte that we're interested in this iteration and copy to RetBuf
		if(CurrCh==Ch){
			*RetPos = Idx;
			return 0;
		}
		Idx++;
		ModOffs++;
	}
	//
	return -1;
}
